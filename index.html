<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Trading Dashboard Pro (Enhanced)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
        }

        .glass-widget {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .tab-active {
            border-color: #3b82f6;
            color: #eff6ff;
        }

        .tab-inactive {
            border-color: transparent;
            color: #94a3b8;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: #3b82f6;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="text-gray-200 antialiased">

    <div id="loading-overlay" class="fixed inset-0 bg-slate-900 bg-opacity-80 flex justify-center items-center z-50">
        <div class="text-center">
            <div class="loader"></div>
            <p id="loading-text" class="mt-4 text-lg font-semibold text-gray-300">Initializing...</p>
        </div>
    </div>

    <div class="min-h-screen p-4 sm:p-6 lg:p-8">
        <header class="flex justify-between items-center mb-4">
            <div>
                <h1 class="text-3xl font-bold text-white">AI Trading Dashboard Pro</h1>
                <p class="text-md text-gray-400">Enhanced Hybrid Strategy</p>
            </div>
            <div class="flex items-center space-x-4">
                <div class="text-right">
                    <p class="text-sm text-gray-500">Bot Status</p>
                    <div class="flex items-center justify-end">
                        <span id="status-dot" class="h-3 w-3 rounded-full bg-red-500 mr-2"></span>
                        <p id="status-text" class="text-lg font-semibold text-white">Idle</p>
                    </div>
                </div>
                <button id="start-stop-btn"
                    class="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-500 text-white font-bold py-2 px-5 rounded-lg transition-all duration-200 shadow-lg">
                    Start Bot
                </button>
            </div>
        </header>

        <!-- Tabs -->
        <div class="mb-6">
            <div class="border-b border-gray-700">
                <nav id="tabs" class="-mb-px flex space-x-6" aria-label="Tabs">
                    <a href="#dashboard"
                        class="tab-active whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm transition-colors">Dashboard</a>
                    <a href="#positions"
                        class="tab-inactive whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm transition-colors">Positions</a>
                    <a href="#settings"
                        class="tab-inactive whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm transition-colors">Settings
                        & Data</a>
                </nav>
            </div>
        </div>

        <!-- Tab Content -->
        <main id="tab-content">
            <!-- Dashboard Tab -->
            <div id="dashboard-content" class="">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <div class="glass-widget p-5 rounded-2xl">
                        <h3 class="text-gray-400 text-sm font-medium">Portfolio Value</h3>
                        <p id="portfolio-value" class="text-3xl font-bold text-white mt-1">$0.00</p>
                    </div>
                    <div class="glass-widget p-5 rounded-2xl">
                        <h3 class="text-gray-400 text-sm font-medium">Today's P/L</h3>
                        <p id="today-pl" class="text-3xl font-bold text-gray-500 mt-1">$0.00</p>
                    </div>
                    <div class="glass-widget p-5 rounded-2xl">
                        <h3 class="text-gray-400 text-sm font-medium">Total P/L</h3>
                        <p id="total-pl" class="text-3xl font-bold text-white mt-1">$0.00</p>
                    </div>
                </div>
                <div class="grid grid-cols-1 xl:grid-cols-5 gap-6">
                    <div class="xl:col-span-3 glass-widget rounded-2xl p-6 shadow-2xl h-96">
                        <h3 class="text-xl font-semibold mb-4 text-white">Portfolio Performance</h3>
                        <canvas id="performance-chart"></canvas>
                    </div>
                    <div class="xl:col-span-2 glass-widget rounded-2xl p-6 shadow-2xl flex flex-col h-96">
                        <h3 class="text-xl font-semibold mb-4 text-white">Event Log</h3>
                        <div id="event-log" class="flex-grow overflow-y-auto space-y-2 pr-2 custom-scrollbar">
                            <p class="text-gray-400 italic">Bot is idle. Configure settings and press Start.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Positions Tab -->
            <div id="positions-content" class="hidden">
                <div class="glass-widget rounded-2xl p-6 shadow-2xl">
                    <h3 class="text-xl font-semibold mb-4 text-white">Open Positions</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full text-sm text-left text-gray-300">
                            <thead class="text-xs text-gray-400 uppercase bg-gray-900/30">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Symbol</th>
                                    <th scope="col" class="px-6 py-3">Qty</th>
                                    <th scope="col" class="px-6 py-3 text-right">Entry Price</th>
                                    <th scope="col" class="px-6 py-3 text-right">Current Price</th>
                                    <th scope="col" class="px-6 py-3 text-right">P/L</th>
                                    <th scope="col" class="px-6 py-3 text-right">Broker Stop</th>
                                    <th scope="col" class="px-6 py-3 text-right">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="positions-table-body">
                                <tr>
                                    <td colspan="7" class="text-center py-8 text-gray-500">No open positions.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-content" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="glass-widget rounded-2xl p-6 shadow-2xl">
                        <h3 class="text-xl font-semibold text-white mb-4">API Credentials</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="alpaca-key" class="block mb-1 text-sm font-medium text-gray-400">Alpaca Key ID</label>
                                <input type="text" id="alpaca-key" placeholder="Enter your Alpaca Key ID"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <div>
                                <label for="alpaca-secret" class="block mb-1 text-sm font-medium text-gray-400">Alpaca Secret Key</label>
                                <input type="password" id="alpaca-secret" placeholder="Enter your Alpaca Secret Key"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <div>
                                <label for="gemini-key" class="block mb-1 text-sm font-medium text-gray-400">Gemini API Key</label>
                                <input type="password" id="gemini-key" placeholder="Enter your Gemini API Key"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <p class="text-xs text-gray-500">API Keys are stored in your browser's local storage.</p>
                        </div>
                    </div>
                    <div class="glass-widget rounded-2xl p-6 shadow-2xl">
                        <h3 class="text-xl font-semibold text-white mb-4">Trading Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="risk-per-trade"
                                    class="block mb-2 text-sm font-medium text-gray-400">Portfolio Risk per Trade
                                    (%)</label>
                                <input type="number" id="risk-per-trade" value="1"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <div>
                                <label for="max-concurrent-scalps"
                                    class="block mb-2 text-sm font-medium text-gray-400">Max Concurrent Trades</label>
                                <input type="number" id="max-concurrent-scalps" value="5"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <div>
                                <label for="limit-order-offset"
                                    class="block mb-2 text-sm font-medium text-gray-400">Limit Order Offset (%)</label>
                                <input type="number" id="limit-order-offset" value="0.05" step="0.01"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                                    title="Percent above the bid to place a limit order for faster fills. e.g., 0.05 for 5 basis points.">
                            </div>
                            <div>
                                <label for="ai-analysis-freq" class="block mb-2 text-sm font-medium text-gray-400">AI
                                    Analysis Frequency (min)</label>
                                <input type="number" id="ai-analysis-freq" value="30"
                                    class="w-full bg-slate-800 border border-slate-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                        </div>
                    </div>
                    <div class="md:col-span-2 flex justify-end items-end">
                        <button id="save-settings-btn"
                            class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-200 shadow-lg">Save
                            All Settings</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="toast-container" class="fixed bottom-5 right-5 z-50"></div>

    <script type="module">
        // --- GLOBAL STATE & CONFIG ---
        const UI = {
            loadingOverlay: document.getElementById('loading-overlay'),
            loadingText: document.getElementById('loading-text'),
            startStopBtn: document.getElementById('start-stop-btn'),
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            portfolioValue: document.getElementById('portfolio-value'),
            todayPL: document.getElementById('today-pl'),
            totalPL: document.getElementById('total-pl'),
            eventLog: document.getElementById('event-log'),
            positionsTableBody: document.getElementById('positions-table-body'),
            performanceChartCanvas: document.getElementById('performance-chart'),
            toastContainer: document.getElementById('toast-container'),
            tabs: document.getElementById('tabs').querySelectorAll('a'),
            tabContents: document.getElementById('tab-content').querySelectorAll('div[id$="-content"]'),
            settings: {
                alpacaKey: document.getElementById('alpaca-key'),
                alpacaSecret: document.getElementById('alpaca-secret'),
                geminiKey: document.getElementById('gemini-key'),
                riskPerTrade: document.getElementById('risk-per-trade'),
                maxConcurrentScalps: document.getElementById('max-concurrent-scalps'),
                limitOrderOffset: document.getElementById('limit-order-offset'),
                aiAnalysisFreq: document.getElementById('ai-analysis-freq'),
                saveBtn: document.getElementById('save-settings-btn'),
            }
        };

        const state = {
            isBotRunning: false,
            userId: null,
            apiKeys: { alpacaKey: '', alpacaSecret: '', geminiKey: '' },
            settings: { riskPerTrade: 1, maxConcurrentScalps: 5, limitOrderOffset: 0.05, aiAnalysisFreq: 30 },
            portfolio: { equity: 0, last_equity: 0, initial_equity: 0 },
            positions: [],
            tradeCycleInterval: null,
            aiAnalysisInterval: null,
            performanceData: [],
            aiWatchlist: [],
            lastTradeDate: null,
            isFirstTradeMadeToday: false,
        };

        let performanceChart;

        // --- INITIALIZATION ---
        window.onload = async () => {
            setLoadingText("Initializing Application...");
            await initializeAppLogic();
            setupEventListeners();
            initializeChart();
        };

        async function initializeAppLogic() {
            let userId = localStorage.getItem('tradingBotUserId_enhanced');
            if (!userId) {
                userId = `user_${Date.now()}`;
                localStorage.setItem('tradingBotUserId_enhanced', userId);
            }
            state.userId = userId;

            setLoadingText("Loading settings and data...");
            await loadSettings();
            await loadDataFromFile();
            logMessage("App initialized. Configure settings if needed.", "action");
            UI.loadingOverlay.style.display = 'none';
        }

        // --- CORE LOGIC ---
        function startBot() {
            if (!state.apiKeys.alpacaKey || !state.apiKeys.alpacaSecret || !state.apiKeys.geminiKey) {
                showToast("Alpaca and Gemini API keys are required.", "error");
                return;
            }
            state.isBotRunning = true;
            UI.startStopBtn.textContent = 'Stop Bot';
            UI.startStopBtn.classList.replace('bg-blue-600', 'bg-red-600');
            UI.startStopBtn.classList.replace('hover:bg-blue-700', 'hover:bg-red-700');
            updateStatus('Active', 'bg-green-500');
            logMessage('Bot started. Initializing cycles.', 'signal');

            tradeCycle(); // Run immediately
            state.tradeCycleInterval = setInterval(tradeCycle, 30 * 1000); 

            runAiDrivenAnalysis(); // Run immediately
            const aiIntervalMs = (state.settings.aiAnalysisFreq || 30) * 60 * 1000;
            state.aiAnalysisInterval = setInterval(runAiDrivenAnalysis, aiIntervalMs);
        }

        async function stopBot() {
            state.isBotRunning = false;
            clearInterval(state.tradeCycleInterval);
            clearInterval(state.aiAnalysisInterval);
            await saveDataAndSettings(true); // Final save
            UI.startStopBtn.textContent = 'Start Bot';
            UI.startStopBtn.classList.replace('bg-red-600', 'bg-blue-600');
            UI.startStopBtn.classList.replace('hover:bg-red-700', 'hover:bg-blue-700');
            updateStatus('Idle', 'bg-red-500');
            logMessage('Bot stopped by user.', 'action');
        }

        async function tradeCycle() {
            if (!state.isBotRunning) return;

            try {
                const today = new Date().toLocaleDateString();
                if (state.lastTradeDate !== today) {
                    logMessage(`New trading day detected. Resetting daily flags.`, 'signal');
                    state.isFirstTradeMadeToday = false;
                    state.lastTradeDate = today;
                }

                logMessage("Starting trade cycle...", "action");
                await updatePortfolioAndPositions();

                if (isMarketOpen()) {
                    await runScalpingStrategy();
                } else {
                    logMessage("Market is closed. Skipping scalping.", "action");
                }

                await recordPerformance();
                await saveDataAndSettings();
                logMessage("Trade cycle finished.", "action");

            } catch (error) {
                logMessage(`Trade cycle error: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // --- STRATEGIES ---
        async function runAiDrivenAnalysis() {
            if (!state.isBotRunning) return;
            logMessage("Executing periodic AI market analysis.", "signal");
            try {
                const newsData = await alpacaFetch('/v1beta1/news?limit=50&sort=desc');
                const headlines = (newsData.news || []).map(item => item.headline).join('\n');

                if (!headlines) {
                    logMessage("No recent headlines found from Alpaca News API.", "action");
                    return;
                }
                
                const moversData = await alpacaFetch('/v1beta1/screener/stocks/most-actives?top=10');
                
                if (!moversData || moversData.most_actives.length === 0) {
                     logMessage("Could not identify any market movers from Alpaca. AI analysis paused.", "action");
                     return;
                }
                const candidates = moversData.most_actives;

                const recommendedStocks = [];
                for (const candidate of candidates) {
                    const symbol = candidate.symbol;
                    logMessage(`AI analyzing candidate: ${symbol}`, "action");
                    try {
                        
                        const indicators = await getIndicators(symbol);
                        if (!indicators) {
                            logMessage(`Insufficient technical data for ${symbol}. Skipping.`, "action");
                            continue;
                        }

                        const recommendation = await getAiRecommendationForStock(headlines, indicators);

                        if (recommendation && recommendation.decision === 'BUY' && recommendation.confidence >= 7) {
                            recommendedStocks.push({ ...recommendation, ...indicators });
                        }
                    } catch (e) { logMessage(`Error analyzing ${symbol}: ${e.message}`, 'error'); }
                }

                if (recommendedStocks.length > 0) {
                    state.aiWatchlist = recommendedStocks.sort((a, b) => b.confidence - a.confidence);
                    const tickers = state.aiWatchlist.map(s => `${s.ticker} (Conf: ${s.confidence})`).join(', ');
                    logMessage(`AI analysis complete. New watchlist: ${tickers}`, "signal");
                } else {
                    logMessage("AI analysis did not yield any new high-confidence recommendations.", "action");
                }

            } catch (e) { logMessage(`AI analysis failed: ${e.message}`, 'error'); }
        }
        
        async function getIndicators(symbol) {
             try {
                const now = new Date();
                const start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString(); // 30 days ago
                
                const [bars5m, bars1m] = await Promise.all([
                     alpacaFetch(`/v2/stocks/${symbol}/bars?timeframe=5Min&start=${start}&limit=200`),
                     alpacaFetch(`/v2/stocks/${symbol}/bars?timeframe=1Min&start=${start}&limit=200`),
                ]);
                
                if (!bars5m || !bars1m || bars5m.bars.length < 20 || bars1m.bars.length < 20) return null;

                const closePrices5m = bars5m.bars.map(b => b.c);
                const closePrices1m = bars1m.bars.map(b => b.c);

                return {
                    symbol: symbol,
                    currentPrice: closePrices5m[closePrices5m.length - 1],
                    rsi5m: calculateRSI(closePrices5m),
                    rsi1m: calculateRSI(closePrices1m),
                    atr: calculateATR(bars5m.bars),
                    macd: calculateMACD(closePrices5m),
                };

             } catch(e) {
                console.error(`Failed to get indicators for ${symbol}:`, e);
                return null;
             }
        }

        async function getAiRecommendationForStock(newsHeadlines, stockData) {
            const prompt = `As a Tier-1 Hedge Fund Analyst, provide a 'BUY' or 'HOLD' decision for an intraday scalping strategy.
                Base your decision on a 50/50 weighting of general market news and the stock's specific quantitative data.
                A 'BUY' is warranted if the stock shows strong technicals (bullish MACD, high ATR for volatility) and the news is supportive.
                A 'HOLD' is warranted if data is mixed, neutral, or negative. Do not recommend 'SELL'.

                Respond ONLY with the following JSON format:
                {
                    "ticker": "${stockData.symbol}",
                    "decision": "BUY" or "HOLD",
                    "confidence": A score from 1 (low) to 10 (high) on your conviction,
                    "reasoning": "Brief justification synthesizing all data points."
                }

                --- DATA ---
                **General Market News:** ${newsHeadlines}
                **Stock Specifics for ${stockData.symbol}:**
                - Price: ${stockData.currentPrice}, 5-min RSI: ${stockData.rsi5m.toFixed(2)}, 5-min ATR: ${stockData.atr.toFixed(4)}
                - 5-min MACD: ${stockData.macd.macd.toFixed(4)}, 5-min MACD Signal: ${stockData.macd.signal.toFixed(4)}
                --- END DATA ---
            `;

            try {
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${state.apiKeys.geminiKey}`;
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                if (!response.ok) {
                    const error = await response.json(); throw new Error(`Gemini API Error: ${error.error.message}`);
                }

                const data = await response.json();
                const jsonString = data.candidates[0].content.parts[0].text.replace(/```json|```/g, '').trim();
                return JSON.parse(jsonString);

            } catch (e) {
                logMessage(`Gemini parsing failed for ${stockData.symbol}: ${e.message}`, 'error');
                return null;
            }
        }

        async function runScalpingStrategy() {
            logMessage("Executing scalping scan.", "signal");

            if (state.aiWatchlist.length === 0) return;
            if (state.positions.length >= state.settings.maxConcurrentScalps) {
                logMessage("Max concurrent positions reached.", "action");
                return;
            }
             
            // First trade logic
            if (!state.isFirstTradeMadeToday) {
                logMessage("Attempting first trade of the day based on pure AI conviction.", "signal");
                const stock = state.aiWatchlist[0];
                if (stock && !state.positions.some(p => p.symbol === stock.ticker)) {
                    await executeTrade(stock);
                    state.isFirstTradeMadeToday = true;
                    return; 
                }
            }
            
            // Subsequent trade logic
            logMessage("Scanning for entries based on full technical analysis.", "action");
            for (const stock of state.aiWatchlist) {
                if (state.positions.some(p => p.symbol === stock.ticker)) continue;
                
                const is5minTrendBullish = stock.macd.macd > stock.macd.signal;
                const isRsiPullback = stock.rsi1m < 40; // Simplified pullback logic

                if (is5minTrendBullish && isRsiPullback) {
                    logMessage(`Entry signal confirmed for ${stock.ticker} (5m Trend Bullish, 1m RSI < 40)`, 'buy');
                    await executeTrade(stock);
                }
            }
        }
        
        async function executeTrade(stock) {
             try {
                const symbol = stock.ticker;
                const quote = await alpacaFetch(`/v2/stocks/${symbol}/quotes/latest`);
                const currentPrice = quote.quote.ap;
                
                const capitalToRisk = state.portfolio.equity * (state.settings.riskPerTrade / 100);
                const stopLossDistance = 2 * stock.atr;
                const quantity = Math.floor(capitalToRisk / stopLossDistance);
                const stopPrice = (currentPrice - stopLossDistance).toFixed(2);

                if (quantity > 0) {
                    logMessage(`Sizing trade for ${symbol}: ${quantity} shares, stop at $${stopPrice}`, 'action');
                    const limitPrice = (quote.quote.bp * (1 + (state.settings.limitOrderOffset / 100))).toFixed(2);
                    await placeBracketOrder(symbol, quantity, 'buy', limitPrice, stopPrice);
                }
             } catch(e) {
                logMessage(`Could not execute trade for ${stock.ticker}: ${e.message}`, 'error');
             }
        }

        async function placeBracketOrder(symbol, qty, side, limit_price, stop_price) {
            const order = {
                symbol, qty, side, type: 'limit', time_in_force: 'day',
                limit_price, order_class: 'bracket',
                stop_loss: { stop_price },
            };
            logMessage(`Placing bracket order: ${side.toUpperCase()} ${qty} ${symbol} @${limit_price} with stop @${stop_price}`, 'action');
            try {
                const conf = await alpacaFetch('/v2/orders', { method: 'POST', body: JSON.stringify(order) });
                logMessage(`Bracket order for ${symbol} submitted. ID: ${conf.id}.`, side === 'buy' ? 'buy' : 'sell');
                showToast(`Order placed: ${side.toUpperCase()} ${qty} ${symbol}`, 'success');
                await new Promise(res => setTimeout(res, 2000));
                await updatePortfolioAndPositions();
                return conf;
            } catch (e) {
                logMessage(`Bracket order failed for ${symbol}: ${e.message}`, 'error');
                showToast(`Order failed for ${symbol}`, 'error');
                return null;
            }
        }

        async function closePosition(symbol) {
            logMessage(`Attempting to cancel open orders and liquidate ${symbol}...`, 'action');
            try {
                await alpacaFetch(`/v2/orders?status=open&symbols=${symbol}`, { method: 'DELETE' });
                logMessage(`Cancelled open orders for ${symbol}.`, 'action');

                await alpacaFetch(`/v2/positions/${symbol}`, { method: 'DELETE' });
                logMessage(`Liquidation order for ${symbol} submitted.`, 'sell');
                showToast(`Closing position in ${symbol}.`, 'success');
                await new Promise(res => setTimeout(res, 2000));
                await updatePortfolioAndPositions();
            } catch (e) {
                logMessage(`Failed to close position for ${symbol}: ${e.message}`, 'error');
                showToast(`Failed to close ${symbol}.`, 'error');
            }
        }

        // --- API HELPERS ---
        async function fetchWithBackoff(url, options, retries = 3, delay = 2000) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    if (response.status === 401) {
                        showToast("Authentication Failed. Check your Alpaca API Keys in Settings.", "error");
                        if (state.isBotRunning) stopBot();
                        throw new Error(`Authentication Failed (401). Please check your API keys.`);
                    }
                    if (response.status === 429 && retries > 0) {
                        logMessage(`Rate limit hit. Retrying in ${delay / 1000}s...`, 'error');
                        await new Promise(res => setTimeout(res, delay));
                        return fetchWithBackoff(url, options, retries - 1, delay * 2);
                    }
                    const errorText = await response.text();
                    throw new Error(`API Error (${response.status}): ${errorText}`);
                }
                if (response.status === 204) return true;

                return await response.json();
            } catch (error) {
                if (retries > 0 && !error.message.includes("401")) {
                    await new Promise(res => setTimeout(res, delay));
                    return fetchWithBackoff(url, options, retries - 1, delay * 2);
                }
                throw error;
            }
        }

        async function alpacaFetch(endpoint, options = {}) {
            let url;
            if (endpoint.startsWith('/v1beta1/') || endpoint.startsWith('/v2/stocks')) {
                url = `https://data.alpaca.markets${endpoint}`;
            } else {
                url = `https://paper-api.alpaca.markets${endpoint}`;
            }

            const headers = {
                'APCA-API-KEY-ID': state.apiKeys.alpacaKey,
                'APCA-API-SECRET-KEY': state.apiKeys.alpacaSecret,
            };

            if (options.body) {
                headers['Content-Type'] = 'application/json';
            }

            return fetchWithBackoff(url, { ...options, headers });
        }

        async function updatePortfolioAndPositions() {
            logMessage("Fetching latest portfolio and position data...", "action");
            try {
                const [account, positions, orders] = await Promise.all([
                    alpacaFetch('/v2/account'),
                    alpacaFetch('/v2/positions'),
                    alpacaFetch('/v2/orders?status=open&nested=true')
                ]);

                if (state.portfolio.initial_equity === 0 && account.equity) {
                    state.portfolio.initial_equity = parseFloat(account.equity);
                }
                state.portfolio.equity = parseFloat(account.equity);
                state.portfolio.last_equity = parseFloat(account.last_equity);

                state.positions = positions.map(p => {
                    const bracketOrder = orders.find(o => o.symbol === p.symbol && o.order_class === 'bracket');
                    const stopOrder = bracketOrder ? bracketOrder.legs.find(leg => leg.order_type === 'stop') : null;
                    return { ...p, stop_price: stopOrder ? stopOrder.stop_price : null };
                });

                updateDashboardUI();
                renderPositionsTable();
            } catch (e) {
                logMessage(`Could not update from Alpaca: ${e.message}`, 'error');
                if (state.isBotRunning) stopBot();
            }
        }
        
        // --- INDICATOR CALCULATIONS ---
        function calculateRSI(prices, period = 14) {
            if (prices.length < period) return 50; // Not enough data
            let gains = 0;
            let losses = 0;

            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff >= 0) { gains += diff; } else { losses -= diff; }
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;

            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i-1];
                if (diff >= 0) {
                    avgGain = (avgGain * (period - 1) + diff) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) - diff) / period;
                }
            }
            
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateATR(bars, period = 14) {
            if(bars.length < period) return 0;
            let trs = [];
            for (let i = 1; i < bars.length; i++) {
                const high = bars[i].h;
                const low = bars[i].l;
                const prevClose = bars[i - 1].c;
                const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
                trs.push(tr);
            }
            const atr = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
            return atr;
        }

        function calculateMACD(prices, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
            if (prices.length < longPeriod) return { macd: 0, signal: 0, histogram: 0};
            const calculateEMA = (data, period) => {
                const k = 2 / (period + 1);
                let ema = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    ema.push(data[i] * k + ema[i - 1] * (1 - k));
                }
                return ema;
            };

            const shortEMA = calculateEMA(prices, shortPeriod);
            const longEMA = calculateEMA(prices, longPeriod);
            
            let macdLine = [];
            for (let i = 0; i < prices.length; i++) {
                if (i >= longPeriod - 1) {
                     const longIndex = i - (longPeriod - 1);
                     const shortIndex = i - (shortPeriod - 1);
                     if (shortEMA[shortIndex] !== undefined && longEMA[longIndex] !== undefined) {
                        macdLine.push(shortEMA[shortIndex] - longEMA[longIndex]);
                     }
                }
            }
            
            if (macdLine.length < signalPeriod) return { macd: 0, signal: 0, histogram: 0};

            const signalLine = calculateEMA(macdLine, signalPeriod);
            const macd = macdLine[macdLine.length-1];
            const signal = signalLine[signalLine.length-1];
            return { macd, signal, histogram: macd - signal };
        }


        // --- DATA PERSISTENCE (ORIGIN PRIVATE FILE SYSTEM) ---
        async function getOpfsFileHandle(create = false) {
            try {
                const root = await navigator.storage.getDirectory();
                const fileHandle = await root.getFileHandle('trading_bot_data.json', { create });
                return fileHandle;
            } catch (error) {
                if (error.name === 'NotFoundError') return null;
                logMessage(`Could not access secure file storage: ${error.message}`, "error");
                return null;
            }
        }

        async function loadDataFromFile() {
            const fileHandle = await getOpfsFileHandle();
            if (!fileHandle) {
                logMessage("No local data file found. A new one will be created on save.", "action");
                return;
            }

            try {
                const file = await fileHandle.getFile();
                const contents = await file.text();

                if (contents) {
                    const data = JSON.parse(contents);

                    if (data.settings) {
                        applySettings({ settings: data.settings, apiKeys: state.apiKeys });
                    }

                    if (data.performanceData && data.initialEquity) {
                        state.performanceData = data.performanceData.map(d => ({ ...d, x: new Date(d.x) }));
                        state.portfolio.initial_equity = data.initialEquity;
                        if (state.performanceData.length > 0) {
                            const lastEntry = state.performanceData[state.performanceData.length - 1];
                            state.portfolio.equity = lastEntry.y;
                            state.portfolio.last_equity = lastEntry.y;
                        }
                    }
                    
                    state.isFirstTradeMadeToday = data.isFirstTradeMadeToday || false;
                    state.lastTradeDate = data.lastTradeDate || null;


                    updatePerformanceChart();
                    updateDashboardUI();
                    logMessage(`Data loaded from secure storage.`, "action");
                }
            } catch (error) {
                logMessage(`Failed to read from data file: ${error.message}`, "error");
            }
        }

        async function saveDataAndSettings(force = false) {
            if (!state.isBotRunning && !force) return;

            const fileHandle = await getOpfsFileHandle(true); // create = true
            if (!fileHandle) {
                logMessage("Automatic save failed: Could not get file handle.", "error");
                return;
            }

            try {
                const dataToSave = {
                    performanceData: state.performanceData,
                    initialEquity: state.portfolio.initial_equity,
                    settings: state.settings,
                    isFirstTradeMadeToday: state.isFirstTradeMadeToday,
                    lastTradeDate: state.lastTradeDate,
                    lastUpdated: new Date().toISOString()
                };
                const dataStr = JSON.stringify(dataToSave, null, 2);

                const writable = await fileHandle.createWritable();
                await writable.write(dataStr);
                await writable.close();

                localStorage.setItem(`tradingBotSettings_${state.userId}`, JSON.stringify({ apiKeys: state.apiKeys, settings: state.settings }));

                if (force) {
                    logMessage("Data and settings saved to secure storage.", "action");
                    showToast("Settings saved successfully.", "success");
                }

            } catch (error) {
                logMessage(`Automatic save failed: ${error.message}`, "error");
            }
        }

        async function saveSettings() {
            const settingsData = {
                apiKeys: {
                    alpacaKey: UI.settings.alpacaKey.value,
                    alpacaSecret: UI.settings.alpacaSecret.value,
                    geminiKey: UI.settings.geminiKey.value,
                },
                settings: {
                    riskPerTrade: parseFloat(UI.settings.riskPerTrade.value),
                    maxConcurrentScalps: parseInt(UI.settings.maxConcurrentScalps.value, 10),
                    limitOrderOffset: parseFloat(UI.settings.limitOrderOffset.value),
                    aiAnalysisFreq: parseInt(UI.settings.aiAnalysisFreq.value, 10)
                }
            };
            localStorage.setItem(`tradingBotSettings_${state.userId}`, JSON.stringify(settingsData));
            applySettings(settingsData);
            await saveDataAndSettings(true);
        }

        async function loadSettings() {
            const localSettings = localStorage.getItem(`tradingBotSettings_${state.userId}`);
            if (localSettings) {
                applySettings(JSON.parse(localSettings));
            }
        }

        function applySettings(data) {
            if (!data) return;
            if (data.apiKeys) {
                state.apiKeys = { ...state.apiKeys, ...data.apiKeys };
            }
            if (data.settings) {
                state.settings = { ...state.settings, ...data.settings };
            }

            UI.settings.alpacaKey.value = state.apiKeys.alpacaKey || '';
            UI.settings.alpacaSecret.value = state.apiKeys.alpacaSecret || '';
            UI.settings.geminiKey.value = state.apiKeys.geminiKey || '';
            UI.settings.riskPerTrade.value = state.settings.riskPerTrade;
            UI.settings.maxConcurrentScalps.value = state.settings.maxConcurrentScalps;
            UI.settings.limitOrderOffset.value = state.settings.limitOrderOffset;
            UI.settings.aiAnalysisFreq.value = state.settings.aiAnalysisFreq;
        }

        async function recordPerformance() {
            if (!state.portfolio.equity || state.portfolio.equity === 0) return;
            const timestamp = new Date();
            state.performanceData.push({ x: timestamp, y: state.portfolio.equity });
            updatePerformanceChart();
        }

        // --- UI & RENDERING ---
        function setupEventListeners() {
            window.addEventListener('pagehide', (e) => {
                if (state.isBotRunning) {
                    saveDataAndSettings(true);
                }
            });
            UI.startStopBtn.addEventListener('click', () => state.isBotRunning ? stopBot() : startBot());
            UI.settings.saveBtn.addEventListener('click', saveSettings);
            UI.tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    e.preventDefault();
                    UI.tabs.forEach(t => t.classList.replace('tab-active', 'tab-inactive'));
                    tab.classList.replace('tab-inactive', 'tab-active');
                    UI.tabContents.forEach(content => content.classList.add('hidden'));
                    const contentId = tab.getAttribute('href').substring(1) + '-content';
                    document.getElementById(contentId).classList.remove('hidden');
                });
            });
            UI.positionsTableBody.addEventListener('click', async (e) => {
                const button = e.target.closest('button');
                if (button && button.dataset.action === 'close') {
                    const symbol = button.dataset.symbol;
                    if (symbol) {
                        button.disabled = true;
                        button.textContent = 'Closing...';
                        await closePosition(symbol);
                    }
                }
            });
        }

        function updateDashboardUI() {
            UI.portfolioValue.textContent = `$${state.portfolio.equity.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            const todayPL = state.portfolio.equity - state.portfolio.last_equity;
            UI.todayPL.textContent = `$${todayPL.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            UI.todayPL.className = `text-3xl font-bold mt-1 ${todayPL >= 0 ? 'text-green-400' : 'text-red-400'}`;

            const totalPL = state.portfolio.initial_equity > 0 ? state.portfolio.equity - state.portfolio.initial_equity : 0.00;
            UI.totalPL.textContent = `$${totalPL.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            UI.totalPL.className = `text-3xl font-bold mt-1 ${totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`;
        }

        function renderPositionsTable() {
            if (state.positions.length === 0) {
                UI.positionsTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-8 text-gray-500">No open positions.</td></tr>';
                return;
            }
            UI.positionsTableBody.innerHTML = state.positions.map(pos => {
                const pl = parseFloat(pos.unrealized_pl);
                const plColor = pl >= 0 ? 'text-green-400' : 'text-red-400';
                const stopPriceText = pos.stop_price ? `$${parseFloat(pos.stop_price).toFixed(2)}` : 'N/A';

                return `
                    <tr class="border-b border-gray-700 hover:bg-slate-800">
                        <td class="px-6 py-4 font-medium text-white">${pos.symbol}</td>
                        <td class="px-6 py-4 text-right">${pos.qty}</td>
                        <td class="px-6 py-4 text-right">$${parseFloat(pos.avg_entry_price).toFixed(2)}</td>
                        <td class="px-6 py-4 text-right">$${parseFloat(pos.current_price).toFixed(2)}</td>
                        <td class="px-6 py-4 text-right ${plColor}">$${pl.toFixed(2)} (${(parseFloat(pos.unrealized_plpc) * 100).toFixed(2)}%)</td>
                        <td class="px-6 py-4 text-right text-orange-400">${stopPriceText}</td>
                        <td class="px-6 py-4 text-right"><button data-action="close" data-symbol="${pos.symbol}" class="text-red-500 hover:underline disabled:text-gray-500">Close</button></td>
                    </tr>
                `;
            }).join('');
        }

        function initializeChart() {
            const ctx = UI.performanceChartCanvas.getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                        data: state.performanceData,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2, pointRadius: 0, tension: 0.1, fill: true,
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                        y: { grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function updatePerformanceChart() {
            if (!performanceChart) return;
            performanceChart.data.datasets[0].data = state.performanceData;
            performanceChart.update();
        }

        // --- UTILITIES ---
        function isMarketOpen() {
            const now = new Date();
            const est = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const day = est.getDay();
            const hour = est.getHours();
            const minute = est.getMinutes();
            if (day === 0 || day === 6) return false;
            if (hour < 9 || (hour === 9 && minute < 30)) return false;
            if (hour >= 16) return false;
            return true;
        }

        function logMessage(message, type) {
            const colors = {
                buy: 'text-blue-400', sell: 'text-red-400', signal: 'text-yellow-400',
                action: 'text-gray-400', error: 'text-red-500 font-bold'
            };
            const logEntry = document.createElement('div');
            logEntry.className = `text-sm ${colors[type] || 'text-gray-500'}`;
            logEntry.innerHTML = `<span class="font-mono text-xs">${new Date().toLocaleTimeString()}</span> &raquo; ${message}`;
            const firstChild = UI.eventLog.firstChild;
            if (firstChild && firstChild.nodeName === 'P') UI.eventLog.innerHTML = '';
            UI.eventLog.prepend(logEntry);
        }

        function updateStatus(text, color) {
            UI.statusText.textContent = text;
            UI.statusDot.className = `h-3 w-3 rounded-full ${color} mr-2`;
        }

        function setLoadingText(text) {
            UI.loadingText.textContent = text;
        }

        function showToast(message, type = "info") {
            const colors = {
                info: "bg-blue-500", success: "bg-green-500",
                error: "bg-red-500", warning: "bg-yellow-500"
            };
            const toast = document.createElement("div");
            toast.className = `px-4 py-3 rounded-lg shadow-lg text-white text-sm ${colors[type]} animate-pulse`;
            toast.textContent = message;
            UI.toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.style.transition = "opacity 0.5s ease";
                toast.style.opacity = "0";
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }
    </script>
</body>

</html>

